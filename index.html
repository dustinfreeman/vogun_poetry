<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Vogun Poetry</title>
		<style>
			#container {
				background: #000;
				width: 400px;
				height: 300px;
			}
		</style>
	</head>
	<body>
		<div id="container">
		</div>
	</body>
	<!-- This code built off of Paul Lewis' intro to shaders -->
	<!-- https://twitter.com/aerotwist -->
	<!-- http://aerotwist.com/tutorials/an-introduction-to-shaders-part-1/ -->


	<!-- Shaders -->
	<script type="x-shader/x-vertex" id="vertexshader">
		
		// switch on high precision floats
		#ifdef GL_ES
		precision highp float;
		#endif
		
		//uniform float amplitude;
		//attribute float displacement;
		varying vec3 vNormal;
		varying vec2 vUv;

		void main() {

			vNormal = normal;
			vUv = uv;
			
			// multiply our displacement by the
			// amplitude. The amp will get animated
			// so we'll have animated displacement
			// vec3 newPosition = position + 
			// 				   normal * 
			// 				   vec3(displacement *
			// 						amplitude);

			// gl_Position = projectionMatrix *
			// 			  modelViewMatrix *
			// 			  vec4(newPosition,1.0);

			//gl_Position = projectionMatrix *
			// 			  modelViewMatrix * position;
		}
	</script>
	
	<script type="x-shader/x-fragment" id="fragmentshader">
	
		#ifdef GL_ES
		precision highp float;
		#endif
		
		// same name and type as VS
		varying vec3 vNormal;
		varying vec2 vUv;

		void main() {

			// calc the dot product and clamp
			// 0 -> 1 rather than -1 -> 1
			vec3 light = vec3(0.5,0.2,1.0);
			
			// ensure it's normalized
			light = normalize(light);
			
			float dProd = max(0.0, dot(vNormal, light));
			
			// feed into our frag colour
			gl_FragColor = vec4(dProd, dProd, dProd, 1.0);
			
			//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);

			//voxel shading
			// gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
			// vec2 p = vUv;
			// if ((p.x > 0.1 || p.x < 0.9) &&
			// 	(p.y > 0.1 || p.y < 0.9) ) {
			// 	gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
			// }		
		}
	
	</script>
	
	<!-- End Shaders -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	<script src="js/three.js"></script>
	
	<script type="text/javascript">
	
	var camera, scene, renderer;
	var geometry, shaderMaterial, mesh;

	init();
	animate();

	function init() {

	    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
	    camera.position.z = 100;

	    scene = new THREE.Scene();

	    geometry = new THREE.BoxGeometry(10, 10, 10);

	    shaderMaterial = new THREE.ShaderMaterial({
	    	uniforms: { time: { type: "f", value: 1.0 }, resolution: { type: "v2", value: new THREE.Vector2() } },
			//uniforms:     	uniforms,
			//attributes:     attributes,
			vertexShader:   $('#vertexshader').text(),
			fragmentShader: $('#fragmentshader').text()
		});

	    mesh = new THREE.Mesh(geometry, shaderMaterial);
	    scene.add(mesh);

	    renderer = new THREE.CanvasRenderer();
	    renderer.setSize(window.innerWidth, window.innerHeight);

	    // get the DOM element to attach to
		// - assume we've got jQuery to hand
		var $container = $('#container');
	    // attach the render-supplied DOM element
		$container.append(renderer.domElement);

	}

	function animate() {

	    requestAnimationFrame(animate);

	    mesh.rotation.x += 0.01;
	    mesh.rotation.y += 0.02;

	    renderer.render(scene, camera);

	}
	</script>
</html>